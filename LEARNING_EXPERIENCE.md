# ğŸ“ çº¿ç¨‹æ± å­¦ä¹ è¸©å‘è®°å½•ä¸ç»éªŒæ€»ç»“

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£è®°å½•äº†åœ¨å®ç° C++ çº¿ç¨‹æ± è¿‡ç¨‹ä¸­é‡åˆ°çš„**çœŸå®é—®é¢˜**ã€**ç–‘æƒ‘**å’Œ**è§£å†³æ–¹æ¡ˆ**ã€‚è¿™äº›éƒ½æ˜¯æ–°æ‰‹å­¦ä¹ å¤šçº¿ç¨‹ç¼–ç¨‹æ—¶çš„å¸¸è§å›°æƒ‘ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åæ¥è€…å°‘èµ°å¼¯è·¯ã€‚

---

## ğŸ› é—®é¢˜ 1ï¼šç¨‹åºå¡æ­» - `wait_all()` æ°¸è¿œç­‰å¾…

### é—®é¢˜æè¿°

```bash
$ ./my_thread_pool 
ğŸš€ åˆ›å»ºçº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ•°é‡: 4
5 + 10
15

# å¡åœ¨è¿™é‡Œï¼Œç¨‹åºæ— å“åº”
```

### é”™è¯¯ä»£ç 

```cpp
// .hpp ä¸­çš„ submit()
active_tasks_++;
tasks_.emplace([this, task]() { 
    (*task)();
    active_tasks_--;  // âŒ åœ¨ Lambda å†…éƒ¨ --
    if (active_tasks_ == 0) {
        all_tasks_done_.notify_all();
    }
});

// .cpp ä¸­çš„å·¥ä½œçº¿ç¨‹
task = std::move(tasks_.front());
tasks_.pop();
active_tasks_++;  // âŒ åˆ ++ï¼Œé‡å¤è®¡æ•°ï¼

task();

active_tasks_--;  // âŒ åˆ --ï¼Œè®¡æ•°æ··ä¹±
```

### é—®é¢˜åŸå› 

**åŒé‡è®¡æ•°å¯¼è‡´ `active_tasks_` æ°¸è¿œæ— æ³•å½’é›¶**ï¼š

1. æäº¤æ—¶ `++` ï¼ˆ.hppï¼‰
2. Lambda å†… `--` ï¼ˆ.hppï¼‰
3. å–å‡ºä»»åŠ¡æ—¶åˆ `++` ï¼ˆ.cppï¼‰
4. æ‰§è¡Œå®Œåˆ `--` ï¼ˆ.cppï¼‰

ç»“æœï¼š`+1 -1 +1 -1 = 0`ï¼Ÿä¸å¯¹ï¼æ—¶åºé—®é¢˜å¯¼è‡´è®¡æ•°æ··ä¹±ã€‚

### æ­£ç¡®åšæ³•

**åªåœ¨ä¸€ä¸ªåœ°æ–¹ç®¡ç†è®¡æ•°å™¨**ï¼š

```cpp
// .hpp ä¸­ï¼šåªè´Ÿè´£ ++
active_tasks_++;
tasks_.emplace([this, task]() { 
    (*task)();  // âœ… ä¸ç®¡è®¡æ•°
});

// .cpp ä¸­ï¼šåªè´Ÿè´£ --
task();
active_tasks_--;  // âœ… æ‰§è¡Œå®Œæ‰ --
{
    std::unique_lock<std::mutex> lock(queue_mutex_);
    if (tasks_.empty() && active_tasks_ == 0) {
        all_tasks_done_.notify_all();
    }
}
```

### å­¦åˆ°çš„ç»éªŒ

- âœ… åŸå­å˜é‡çš„ä¿®æ”¹è¦æœ‰æ˜ç¡®çš„è´£ä»»åˆ’åˆ†
- âœ… ä¸è¦åœ¨å¤šä¸ªåœ°æ–¹ä¿®æ”¹åŒä¸€ä¸ªè®¡æ•°å™¨
- âœ… å¦‚æœå¡æ­»ï¼Œä¼˜å…ˆæ£€æŸ¥æ¡ä»¶å˜é‡çš„é€šçŸ¥é€»è¾‘

---

## ğŸ› é—®é¢˜ 2ï¼šç¼–è¯‘é”™è¯¯ - ç¼ºå°‘ `typename` å…³é”®å­—

### é”™è¯¯ä¿¡æ¯

```
error: need 'typename' before 'std::result_of<...>::type' 
because 'std::result_of<...>' is a dependent scope
```

### é”™è¯¯ä»£ç 

```cpp
using return_type = std::result_of<F(Args...)>::type;  // âŒ
```

### é—®é¢˜åŸå› 

åœ¨æ¨¡æ¿ä¸­è®¿é—®**ä¾èµ–äºæ¨¡æ¿å‚æ•°çš„åµŒå¥—ç±»å‹**æ—¶ï¼Œç¼–è¯‘å™¨æ— æ³•åˆ¤æ–­ `::type` æ˜¯ç±»å‹è¿˜æ˜¯é™æ€æˆå‘˜å˜é‡ã€‚

### æ­£ç¡®åšæ³•

```cpp
using return_type = typename std::result_of<F(Args...)>::type;  // âœ…
//                  â†‘ åŠ ä¸Š typename
```

### å­¦åˆ°çš„ç»éªŒ

**`typename` ä½¿ç”¨è§„åˆ™**ï¼š

- âœ… æ¨¡æ¿ä¸­è®¿é—®ä¾èµ–ç±»å‹ â†’ å¿…é¡»åŠ  `typename`
- âœ… éæ¨¡æ¿æˆ–ä¸ä¾èµ–æ¨¡æ¿å‚æ•° â†’ ä¸éœ€è¦ `typename`

```cpp
// éœ€è¦ typename
template<typename T>
void func() {
    typename std::vector<T>::iterator it;  // âœ…
}

// ä¸éœ€è¦ typename
std::vector<int>::iterator it;  // âœ…
```

---

## ğŸ› é—®é¢˜ 3ï¼šç¼–è¯‘é”™è¯¯ - `packaged_task` æ¨¡æ¿å‚æ•°é”™è¯¯

### é”™è¯¯ä»£ç 

```cpp
auto task = std::make_shared<std::packaged_task<return_type>>(  // âŒ
    std::bind(...)
);
```

### é—®é¢˜åŸå› 

`packaged_task` çš„æ¨¡æ¿å‚æ•°å¿…é¡»æ˜¯**å‡½æ•°ç­¾å**ï¼Œä¸æ˜¯è¿”å›ç±»å‹ã€‚

### æ­£ç¡®åšæ³•

```cpp
auto task = std::make_shared<std::packaged_task<return_type()>>(  // âœ…
//                                                          â†‘â†‘
//                                                    åŠ ä¸Š ()
    std::bind(...)
);
```

### ç±»å‹è§£é‡Š

```cpp
// âŒ é”™è¯¯ç¤ºä¾‹
std::packaged_task<int>       // int ä¸æ˜¯å‡½æ•°ç­¾å
std::packaged_task<return_type>  // return_type ä¸æ˜¯å‡½æ•°ç­¾å

// âœ… æ­£ç¡®ç¤ºä¾‹
std::packaged_task<int()>         // å‡½æ•°ç­¾åï¼šæ— å‚æ•°ï¼Œè¿”å› int
std::packaged_task<void(int)>     // å‡½æ•°ç­¾åï¼šæ¥å— intï¼Œè¿”å› void
std::packaged_task<return_type()> // å‡½æ•°ç­¾åï¼šæ— å‚æ•°ï¼Œè¿”å› return_type
```

### å­¦åˆ°çš„ç»éªŒ

- âœ… `packaged_task` éœ€è¦å‡½æ•°ç­¾åï¼š`è¿”å›ç±»å‹(å‚æ•°ç±»å‹...)`
- âœ… `()` è¡¨ç¤ºæ— å‚æ•°
- âœ… å·²ç»ç”¨ `std::bind` ç»‘å®šå‚æ•°åï¼Œå°±æ˜¯æ— å‚å‡½æ•°

---

## â“ ç–‘æƒ‘ 1ï¼š`::type` æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

### åˆå§‹ç†è§£ï¼ˆä¸å®Œå…¨æ­£ç¡®ï¼‰

> "åœ¨æˆ‘å°è±¡é‡Œï¼Œè¿™æ˜¯è¡¨ç¤ºå‘½åç©ºé—´ä¸‹çš„ä¸œè¥¿"

### æ­£ç¡®ç†è§£

`::` æœ‰**ä¸‰ç§ç”¨æ³•**ï¼š

#### 1. å‘½åç©ºé—´

```cpp
std::vector  // std å‘½åç©ºé—´ä¸‹çš„ vector
```

#### 2. è®¿é—®é™æ€æˆå‘˜

```cpp
MyClass::static_function()  // è°ƒç”¨é™æ€å‡½æ•°
MyClass::static_variable    // è®¿é—®é™æ€å˜é‡
```

#### 3. è®¿é—®ç±»å‹æˆå‘˜ï¼ˆtype aliasï¼‰

```cpp
std::vector<int>::size_type      // vector å†…éƒ¨å®šä¹‰çš„ç±»å‹
std::result_of<F(Args...)>::type // result_of å†…éƒ¨å®šä¹‰çš„ç±»å‹
```

### åœ¨çº¿ç¨‹æ± ä¸­çš„ç”¨æ³•

```cpp
std::result_of<F(Args...)>::type
//            â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
//                  â”‚
//          æ¨¡æ¿ç±»å®ä¾‹åŒ–
//                  â†“
//            å†…éƒ¨å®šä¹‰äº† using type = int;
//                  â†“
//            ::type è®¿é—®è¿™ä¸ªç±»å‹
```

### å®Œæ•´ä¾‹å­

```cpp
// result_of çš„ç®€åŒ–å®ç°
template<typename F, typename... Args>
struct result_of<F(Args...)> {
    using type = /* å‡½æ•°Fçš„è¿”å›ç±»å‹ */;
    //    â†‘
    //    ::type è®¿é—®çš„å°±æ˜¯è¿™ä¸ª
};

// ä½¿ç”¨
typename std::result_of<int(*)(int, int)>::type x;  // x çš„ç±»å‹æ˜¯ int
```

---

## â“ ç–‘æƒ‘ 2ï¼šå·¦å€¼ã€å³å€¼åˆ°åº•æ€ä¹ˆç†è§£ï¼Ÿ

### åˆå§‹ç†è§£ï¼ˆé”™è¯¯ï¼‰

> "å·¦å€¼å³å€¼çš„ç†è§£å°±æ˜¯ = çš„å·¦å³ä¸¤è¾¹ï¼Œå·¦è¾¹çš„å€¼å¯ä»¥æ˜¯ä¸å®šçš„ï¼Œå³è¾¹çš„å€¼æ˜¯ä¸€å®šçš„"

### æ­£ç¡®ç†è§£

**ä¸æ˜¯çœ‹ `=` çš„ä½ç½®ï¼è€Œæ˜¯çœ‹èƒ½å¦å–åœ°å€ã€æœ‰æ— åå­—ã€‚**

### åˆ¤æ–­æ–¹æ³•

**é—®è‡ªå·±ï¼šè¿™ä¸ªä¸œè¥¿æœ‰åå­—å—ï¼Ÿèƒ½åœ¨ä¸‹ä¸€è¡Œç»§ç»­ç”¨å—ï¼Ÿ**

```cpp
int a = 10;      // a æ˜¯å·¦å€¼ï¼ˆæœ‰åå­—ï¼‰
int b = a + 5;   // a+5 æ˜¯å³å€¼ï¼ˆä¸´æ—¶è®¡ç®—ç»“æœï¼Œæ²¡åå­—ï¼‰

std::string s1 = "hello";           // s1 æ˜¯å·¦å€¼
std::string s2 = s1 + " world";     // s1+" world" æ˜¯å³å€¼
std::string s3 = std::string("hi"); // std::string("hi") æ˜¯å³å€¼
```

### ç‰¹æ€§å¯¹æ¯”è¡¨

| ç‰¹æ€§ | å·¦å€¼ | å³å€¼ |
|------|------|------|
| æœ‰åå­— | âœ… | âŒ |
| æœ‰åœ°å€ | âœ… | âŒ |
| å¯ä»¥å–åœ°å€ `&` | âœ… | âŒ |
| ç”Ÿå‘½å‘¨æœŸ | æŒä¹… | ä¸´æ—¶ |
| å¯ä»¥èµ‹å€¼ | âœ… (éconst) | âŒ |

### ä¾‹å­

```cpp
int x = 10;
int* p = &x;        // âœ… å¯ä»¥å–å·¦å€¼çš„åœ°å€
int* p2 = &(x+5);   // âŒ ä¸èƒ½å–å³å€¼çš„åœ°å€

x = 20;             // âœ… å·¦å€¼å¯ä»¥è¢«èµ‹å€¼
10 = x;             // âŒ å³å€¼ä¸èƒ½è¢«èµ‹å€¼
```

### å³å€¼å¼•ç”¨ `&&`

**åœ¨æ¨¡æ¿ä¸­çš„ `&&` æ˜¯"ä¸‡èƒ½å¼•ç”¨"ï¼ˆè½¬å‘å¼•ç”¨ï¼‰**ï¼š

```cpp
// æ¨¡æ¿ä¸­çš„ && = ä¸‡èƒ½å¼•ç”¨
template<typename F>
void submit(F&& f) {  // å¯ä»¥æ¥å—å·¦å€¼æˆ–å³å€¼
    // ...
}

// éæ¨¡æ¿ä¸­çš„ && = å³å€¼å¼•ç”¨
void func(int&& x) {  // åªèƒ½æ¥å—å³å€¼
    // ...
}
```

### `std::forward` çš„ä½œç”¨

**ä¿æŒå‚æ•°çš„åŸå§‹å€¼ç±»åˆ«**ï¼š

```cpp
template<typename T>
void wrapper(T&& x) {
    // ä¸ç”¨ forward
    process(x);  // x æ°¸è¿œæ˜¯å·¦å€¼

    // ç”¨ forward
    process(std::forward<T>(x));  // ä¿æŒåŸå§‹å±æ€§
    // ä¼ å…¥å³å€¼ â†’ è½¬å‘ä¸ºå³å€¼
    // ä¼ å…¥å·¦å€¼ â†’ è½¬å‘ä¸ºå·¦å€¼
}
```

---

## â“ ç–‘æƒ‘ 3ï¼š`notify_one()` å¦‚ä½•ç²¾ç¡®é€šçŸ¥çº¿ç¨‹ï¼Ÿ

### åˆå§‹ç–‘æƒ‘

> "æ˜æ˜åˆ›å»ºçº¿ç¨‹çš„æ—¶å€™ï¼Œè¿˜æœ‰åˆ«çš„ä¹‹ç±»çš„ï¼Œé”ä»€ä¹ˆçš„æ“ä½œï¼Œä¹Ÿæ²¡æœ‰æ˜æ˜¾çš„ç»‘å®š condition_ï¼Œä¸ºä»€ä¹ˆä»–çš„ .notify_one() å°±å¯ä»¥ç²¾ç¡®çš„é€šçŸ¥ä¸€ä¸ªä¼‘çœ çš„çº¿ç¨‹ï¼Ÿ"

### è§£ç­”ï¼šé€šè¿‡åŒä¸€ä¸ªå¯¹è±¡å…³è”

**æ‰€æœ‰çº¿ç¨‹æ“ä½œçš„æ˜¯åŒä¸€ä¸ª `condition_` å¯¹è±¡ï¼**

```cpp
class MyThreadPool {
    std::condition_variable condition_;  // â† åªæœ‰ä¸€ä¸ªå¯¹è±¡
    //                      åœ°å€ï¼š0x12345678
    
    // å·¥ä½œçº¿ç¨‹
    void worker() {
        condition_.wait(...);  // ç­‰å¾… 0x12345678
    }
    
    // ä¸»çº¿ç¨‹
    void submit() {
        condition_.notify_one();  // é€šçŸ¥ 0x12345678
    }
};
```

### å†…éƒ¨æœºåˆ¶ï¼ˆæ“ä½œç³»ç»Ÿå±‚é¢ï¼‰

```
1. çº¿ç¨‹è°ƒç”¨ condition_.wait()
   â†“
2. æ“ä½œç³»ç»ŸæŠŠçº¿ç¨‹åŠ å…¥"condition_ çš„ç­‰å¾…é˜Ÿåˆ—"
   
   ç­‰å¾…é˜Ÿåˆ—ï¼ˆcondition_ å†…éƒ¨ï¼‰:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ çº¿ç¨‹1  â”‚ â† ä¼‘çœ 
   â”‚ çº¿ç¨‹2  â”‚ â† ä¼‘çœ 
   â”‚ çº¿ç¨‹3  â”‚ â† ä¼‘çœ 
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. è°ƒç”¨ condition_.notify_one()
   â†“
4. æ“ä½œç³»ç»Ÿä»é˜Ÿåˆ—å”¤é†’ä¸€ä¸ªçº¿ç¨‹
   
   ç­‰å¾…é˜Ÿåˆ—:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ çº¿ç¨‹2  â”‚ â† è¿˜åœ¨ç¡
   â”‚ çº¿ç¨‹3  â”‚ â† è¿˜åœ¨ç¡
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   
   çº¿ç¨‹1 â† é†’äº†ï¼
```

### `notify_one()` vs `notify_all()`

```cpp
// notify_one()ï¼šå”¤é†’ä¸€ä¸ªçº¿ç¨‹
condition_.notify_one();
// ä½¿ç”¨åœºæ™¯ï¼šæœ‰ä¸€ä¸ªä»»åŠ¡ï¼Œåªéœ€è¦ä¸€ä¸ªçº¿ç¨‹å¤„ç†

// notify_all()ï¼šå”¤é†’æ‰€æœ‰çº¿ç¨‹
condition_.notify_all();
// ä½¿ç”¨åœºæ™¯ï¼š
// 1. çº¿ç¨‹æ± è¦å…³é—­ï¼ˆæ‰€æœ‰çº¿ç¨‹éƒ½éœ€è¦æ£€æŸ¥ stop_ æ ‡å¿—ï¼‰
// 2. æ¡ä»¶å˜åŒ–å½±å“æ‰€æœ‰çº¿ç¨‹
```

---

## â“ ç–‘æƒ‘ 4ï¼šä¸€ä¸ªå¯¹è±¡åªèƒ½æœ‰ä¸€ä¸ª `condition_` å—ï¼Ÿ

### åˆå§‹ç†è§£ï¼ˆé”™è¯¯ï¼‰

> "æ‰€ä»¥æ¯ä¸ªå¯¹è±¡å¼ºåˆ¶åªèƒ½ä¸€ä¸ª condition_ å—ï¼Ÿ"

### æ­£ç¡®ç­”æ¡ˆ

**ä¸æ˜¯ï¼å¯ä»¥æœ‰å¤šä¸ªæ¡ä»¶å˜é‡ï¼Œç”¨äºä¸åŒçš„ç­‰å¾…åœºæ™¯ã€‚**

### ä½ çš„çº¿ç¨‹æ± å°±æœ‰ä¸¤ä¸ª

```cpp
class MyThreadPool {
    std::condition_variable condition_;        // ç”¨äº"æœ‰æ–°ä»»åŠ¡"
    std::condition_variable all_tasks_done_;   // ç”¨äº"æ‰€æœ‰ä»»åŠ¡å®Œæˆ"
};
```

### ä½¿ç”¨åœºæ™¯

```cpp
// condition_ï¼šå·¥ä½œçº¿ç¨‹ç­‰å¾…æ–°ä»»åŠ¡
void worker() {
    condition_.wait(lock, [this]() {
        return stop_ || !tasks_.empty();
    });
}

// all_tasks_done_ï¼šä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
void wait_all() {
    all_tasks_done_.wait(lock, [this]() {
        return tasks_.empty() && active_tasks_ == 0;
    });
}
```

### ç»å…¸ä¾‹å­ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…

```cpp
class BoundedQueue {
    std::condition_variable not_empty_;  // é˜Ÿåˆ—éç©º
    std::condition_variable not_full_;   // é˜Ÿåˆ—æœªæ»¡
    
    void push(int item) {
        not_full_.wait(...);   // ç­‰å¾…é˜Ÿåˆ—æœ‰ç©ºé—´
        // ...
        not_empty_.notify_one();  // é€šçŸ¥æ¶ˆè´¹è€…
    }
    
    int pop() {
        not_empty_.wait(...);  // ç­‰å¾…é˜Ÿåˆ—æœ‰æ•°æ®
        // ...
        not_full_.notify_one();  // é€šçŸ¥ç”Ÿäº§è€…
    }
};
```

---

## â“ ç–‘æƒ‘ 5ï¼š`condition_.wait()` çš„æ‰§è¡Œé€»è¾‘

### ä»£ç 

```cpp
condition_.wait(lock, [this](){
    return stop_ || !tasks_.empty();  
});
```

### å®Œæ•´çš„å†…éƒ¨é€»è¾‘

```cpp
// wait(lock, predicate) ç­‰ä»·äºï¼š

while (!predicate()) {  // 1. æ£€æŸ¥æ¡ä»¶
    lock.unlock();      // 2. é‡Šæ”¾é”
    // 3. çº¿ç¨‹ä¼‘çœ ï¼Œç­‰å¾…é€šçŸ¥
    // ... ä¼‘çœ ä¸­ ...
    // 4. è¢« notify å”¤é†’
    lock.lock();        // 5. é‡æ–°è·å–é”
    // 6. å¾ªç¯å›åˆ°æ­¥éª¤1ï¼Œå†æ¬¡æ£€æŸ¥æ¡ä»¶
}
// 7. æ¡ä»¶æ»¡è¶³ï¼Œwait() è¿”å›
```

### ä¸ºä»€ä¹ˆè¦é‡Šæ”¾é”ï¼Ÿ

**å¦‚æœä¸é‡Šæ”¾é”ä¼šæ­»é”**ï¼š

```
å·¥ä½œçº¿ç¨‹æŒæœ‰é” â†’ ä¼‘çœ 
ä¸»çº¿ç¨‹æƒ³æäº¤ä»»åŠ¡ â†’ éœ€è¦é” â†’ å¡ä½ï¼
æ­»é”ï¼
```

### æ—¶åºå›¾

```
å·¥ä½œçº¿ç¨‹                    ä¸»çº¿ç¨‹                    é”çŠ¶æ€
â”€â”€â”€â”€â”€â”€                    â”€â”€â”€â”€                      â”€â”€â”€â”€â”€â”€
lock(mtx) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   ğŸ”’ å·¥ä½œçº¿ç¨‹
æ£€æŸ¥ï¼šé˜Ÿåˆ—ç©º
unlock(mtx) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   ğŸ”“ é‡Šæ”¾
ğŸ’¤ ä¼‘çœ 
                          lock(mtx) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   ğŸ”’ ä¸»çº¿ç¨‹
                          tasks_.push(...)
                          unlock(mtx) â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   ğŸ”“ é‡Šæ”¾
                          notify_one()
è¢«å”¤é†’ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lock(mtx) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   ğŸ”’ å·¥ä½œçº¿ç¨‹
æ£€æŸ¥ï¼šé˜Ÿåˆ—éç©º âœ…
wait() è¿”å›
```

### è°“è¯å‡½æ•°çš„ä½œç”¨

**é˜²æ­¢è™šå‡å”¤é†’ï¼ˆspurious wakeupï¼‰**ï¼š

```cpp
// æ“ä½œç³»ç»Ÿå¯èƒ½"æ„å¤–"å”¤é†’å¤šä¸ªçº¿ç¨‹
condition_.wait(lock, predicate);

// å³ä½¿è¢«å”¤é†’ï¼Œä¹Ÿè¦æ£€æŸ¥æ¡ä»¶
// æ¡ä»¶ä¸æ»¡è¶³ â†’ ç»§ç»­ç­‰å¾…
// æ¡ä»¶æ»¡è¶³ â†’ è¿”å›
```

---

## â“ ç–‘æƒ‘ 6ï¼š`(*task)()` å’Œ `task()` æ˜¯é‡å¤çš„å—ï¼Ÿ

### åˆå§‹ç†è§£ï¼ˆé”™è¯¯ï¼‰

> "ä¸éƒ½æ˜¯æ‰§è¡Œä»»åŠ¡å—ï¼Œè¿™é‡Œé‡å¤äº†ï¼Ÿ"

### æ­£ç¡®ç­”æ¡ˆ

**ä¸é‡å¤ï¼æ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„ `task`**ï¼š

### åœ¨ `.hpp` ä¸­

```cpp
auto task = std::make_shared<std::packaged_task<return_type()>>(...);
//   â†‘
//   ç±»å‹ï¼šshared_ptr<packaged_task>

(*task)();  // è°ƒç”¨ packaged_task çš„ operator()
```

### åœ¨ `.cpp` ä¸­

```cpp
std::function<void()> task;
//                    â†‘
//                    ç±»å‹ï¼šstd::function

task();  // è°ƒç”¨ std::function çš„ operator()
```

### å®Œæ•´çš„åŒ…è£…å±‚æ¬¡

```
æäº¤ä»»åŠ¡æ—¶çš„åŒ…è£…ï¼š

add(5, 10)  åŸå§‹å‡½æ•°
    â†“
std::bind(add, 5, 10)  ç»‘å®šå‚æ•°
    â†“
packaged_task<int()>  åŒ…è£…æˆ packaged_task
    â†“
shared_ptr<packaged_task>  æ™ºèƒ½æŒ‡é’ˆç®¡ç†
    â†“
Lambda: [task](){ (*task)(); }  åŒ…è£…æˆ Lambda
    â†“
std::function<void()>  å­˜å…¥é˜Ÿåˆ—


æ‰§è¡Œæ—¶çš„è°ƒç”¨é“¾ï¼š

.cpp ä¸­çš„ task()  è°ƒç”¨ std::function
    â†“
æ‰§è¡Œ Lambda
    â†“
Lambda å†…éƒ¨ (*task)()  è°ƒç”¨ shared_ptr æŒ‡å‘çš„ packaged_task
    â†“
æ‰§è¡Œ packaged_task
    â†“
æ‰§è¡ŒåŸå§‹å‡½æ•° add(5, 10)
```

### ä¸ºä»€ä¹ˆè¿™ä¹ˆå¤šå±‚ï¼Ÿ

1. **`std::bind`** - ç»‘å®šå‚æ•°
2. **`packaged_task`** - å…³è” futureï¼Œè·å–è¿”å›å€¼
3. **`shared_ptr`** - å¤šçº¿ç¨‹å…±äº«ï¼Œè‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
4. **`Lambda`** - ç»Ÿä¸€æ¥å£ä¸º `void()`
5. **`std::function`** - é˜Ÿåˆ—å¯ä»¥å­˜å‚¨ä»»æ„å¯è°ƒç”¨å¯¹è±¡

---

## ğŸ¯ æ ¸å¿ƒç»éªŒæ€»ç»“

### 1. åŸå­æ“ä½œä¸åŒæ­¥

- âœ… åŸå­å˜é‡çš„ä¿®æ”¹è¦æœ‰æ˜ç¡®çš„è´£ä»»åˆ’åˆ†
- âœ… é¿å…åœ¨å¤šä¸ªåœ°æ–¹ä¿®æ”¹åŒä¸€ä¸ªè®¡æ•°å™¨
- âœ… æ¡ä»¶å˜é‡çš„é€šçŸ¥æ—¶æœºå¾ˆé‡è¦

### 2. æ¨¡æ¿ç¼–ç¨‹

- âœ… ä¾èµ–æ¨¡æ¿å‚æ•°çš„åµŒå¥—ç±»å‹å¿…é¡»åŠ  `typename`
- âœ… æ¨¡æ¿ä¸­çš„ `&&` æ˜¯ä¸‡èƒ½å¼•ç”¨ï¼Œä¸æ˜¯å³å€¼å¼•ç”¨
- âœ… ä½¿ç”¨ `std::forward` ä¿æŒå‚æ•°çš„åŸå§‹å€¼ç±»åˆ«

### 3. å¤šçº¿ç¨‹è°ƒè¯•

- âœ… ç¨‹åºå¡æ­» â†’ æ£€æŸ¥æ¡ä»¶å˜é‡çš„ç­‰å¾…å’Œé€šçŸ¥
- âœ… æ•°æ®ç«äº‰ â†’ æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å…±äº«æ•°æ®éƒ½æœ‰é”ä¿æŠ¤
- âœ… è®¡æ•°å™¨å¼‚å¸¸ â†’ æ£€æŸ¥ `++` å’Œ `--` æ˜¯å¦é…å¯¹

### 4. ç±»å‹ç†è§£

- âœ… `::` å¯ä»¥è®¿é—®å‘½åç©ºé—´ã€é™æ€æˆå‘˜ã€ç±»å‹æˆå‘˜
- âœ… å·¦å€¼æœ‰åå­—èƒ½å–åœ°å€ï¼Œå³å€¼æ˜¯ä¸´æ—¶çš„
- âœ… `packaged_task` éœ€è¦å‡½æ•°ç­¾åï¼Œä¸æ˜¯è¿”å›ç±»å‹

### 5. æ¡ä»¶å˜é‡

- âœ… å¤šä¸ªæ¡ä»¶å˜é‡å¯ä»¥ç”¨äºä¸åŒçš„ç­‰å¾…åœºæ™¯
- âœ… `wait()` ä¼šè‡ªåŠ¨é‡Šæ”¾é”ï¼Œé¿å…æ­»é”
- âœ… è°“è¯å‡½æ•°é˜²æ­¢è™šå‡å”¤é†’
- âœ… `notify_one()` é€šè¿‡åŒä¸€ä¸ªå¯¹è±¡åœ°å€å…³è”

---

## ğŸ’¡ å­¦ä¹ å»ºè®®

### å¯¹äºåˆå­¦è€…

1. **ä¸è¦æ­»è®°ç¡¬èƒŒ**ï¼Œç†è§£æ¦‚å¿µæ¯”è®°ä½ä»£ç æ›´é‡è¦
2. **é‡åˆ°é”™è¯¯ä¸è¦æ…Œ**ï¼Œç¼–è¯‘å™¨çš„é”™è¯¯ä¿¡æ¯å¾ˆæœ‰ä»·å€¼
3. **å¤šç”»å›¾**ï¼Œç”¨å›¾è§£ç†è§£çº¿ç¨‹é—´çš„äº¤äº’
4. **å†™æµ‹è¯•ä»£ç **ï¼ŒéªŒè¯è‡ªå·±çš„ç†è§£
5. **é—®ä¸ºä»€ä¹ˆ**ï¼Œä¸è¦åªæ»¡è¶³äº"èƒ½è·‘å°±è¡Œ"

### è°ƒè¯•æŠ€å·§

1. **ç¨‹åºå¡æ­»** â†’ æ‰“å°æ—¥å¿—ï¼Œæ‰¾å‡ºå¡åœ¨å“ªé‡Œ
2. **ç¼–è¯‘é”™è¯¯** â†’ ä»”ç»†çœ‹é”™è¯¯ä¿¡æ¯ï¼Œå…³æ³¨ç¬¬ä¸€ä¸ªé”™è¯¯
3. **è¿è¡Œæ—¶å´©æºƒ** â†’ æ£€æŸ¥æŒ‡é’ˆã€é”ã€ç”Ÿå‘½å‘¨æœŸ
4. **ç»“æœä¸å¯¹** â†’ æ£€æŸ¥æ¡ä»¶åˆ¤æ–­ã€è®¡æ•°å™¨ã€æ—¶åº

### è¿›é˜¶æ–¹å‘

- å­¦ä¹ æ— é”ç¼–ç¨‹ï¼ˆlock-freeï¼‰
- ç ”ç©¶å·¥ä½œçªƒå–ç®—æ³•ï¼ˆwork stealingï¼‰
- äº†è§£ C++20 åç¨‹
- é˜…è¯»å¼€æºçº¿ç¨‹æ± å®ç°ï¼ˆIntel TBBã€Boost.Asioï¼‰

---

## ğŸ“š å‚è€ƒèµ„æ–™

- C++ Concurrency in Action (Anthony Williams)
- Effective Modern C++ (Scott Meyers)
- https://en.cppreference.com/w/cpp/thread
- https://www.modernescpp.com/

---

**æœ€åçš„è¯**ï¼š

> å­¦ä¹ å¤šçº¿ç¨‹ç¼–ç¨‹å°±åƒå­¦å¼€è½¦ï¼Œä¸€å¼€å§‹ä¼šçŠ¯å¾ˆå¤šé”™è¯¯ï¼Œè¿™å¾ˆæ­£å¸¸ã€‚é‡è¦çš„æ˜¯ä»é”™è¯¯ä¸­å­¦ä¹ ï¼Œç†è§£æ¯ä¸ªæ¦‚å¿µèƒŒåçš„åŸç†ã€‚ä¸è¦æ°”é¦ï¼ŒåšæŒä¸‹å»ï¼Œä½ ä¸€å®šèƒ½æŒæ¡ï¼ğŸ’ª

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025å¹´11æœˆ4æ—¥  
**é€‚ç”¨èŒƒå›´**: C++11/14/17 çº¿ç¨‹æ± å­¦ä¹ 
